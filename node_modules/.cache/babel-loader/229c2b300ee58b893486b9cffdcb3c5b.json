{"ast":null,"code":"export function DFS(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  DFSUtil(startNode, finishNode, grid, visitedNodesInOrder);\n  return visitedNodesInOrder;\n}\n_c = DFS;\nfunction DFSUtil(node, finishNode, grid, visitedNodesInOrder) {\n  if (!node.isVisited && !node.isWall) {\n    node.isVisited = true;\n    visitedNodesInOrder.push(node);\n    console.log(node);\n    if (node === finishNode) return true;\n    const {\n      row,\n      col\n    } = node;\n    if (row > 0) {\n      if (DFSUtil(grid[row - 1][col], finishNode, grid, visitedNodesInOrder)) {\n        grid[row - 1][col].previousNode = node;\n        return true;\n      }\n    }\n    if (col < grid[0].length - 1) {\n      if (DFSUtil(grid[row][col + 1], finishNode, grid, visitedNodesInOrder)) {\n        grid[row][col + 1].previousNode = node;\n        return true;\n      }\n    }\n    if (row < grid.length - 1) {\n      if (DFSUtil(grid[row + 1][col], finishNode, grid, visitedNodesInOrder)) {\n        grid[row + 1][col].previousNode = node;\n        return true;\n      }\n    }\n    if (col > 0) {\n      if (DFSUtil(grid[row][col - 1], finishNode, grid, visitedNodesInOrder)) {\n        grid[row][col - 1].previousNode = node;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n_c2 = DFSUtil;\nexport function getNodesInPathOfDFS(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\nvar _c, _c2;\n$RefreshReg$(_c, \"DFS\");\n$RefreshReg$(_c2, \"DFSUtil\");","map":{"version":3,"names":["DFS","grid","startNode","finishNode","visitedNodesInOrder","DFSUtil","_c","node","isVisited","isWall","push","console","log","row","col","previousNode","length","_c2","getNodesInPathOfDFS","nodesInShortestPathOrder","currentNode","unshift","$RefreshReg$"],"sources":["C:/Users/hp/Desktop/ShortestPath/Path-Finding-visualiser/src/algorithms/depthFirstSearch.js"],"sourcesContent":["export function DFS(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  DFSUtil(startNode, finishNode, grid, visitedNodesInOrder);\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction DFSUtil(node, finishNode, grid, visitedNodesInOrder) {\r\n  if (!node.isVisited && !node.isWall) {\r\n    node.isVisited = true;\r\n    visitedNodesInOrder.push(node);\r\n    console.log(node);\r\n    if (node === finishNode) return true;\r\n    const { row, col } = node;\r\n    if (row > 0) {\r\n      if (DFSUtil(grid[row - 1][col], finishNode, grid, visitedNodesInOrder)) {\r\n        grid[row - 1][col].previousNode = node;\r\n        return true;\r\n      }\r\n    }\r\n    if (col < grid[0].length - 1) {\r\n      if (DFSUtil(grid[row][col + 1], finishNode, grid, visitedNodesInOrder)) {\r\n        grid[row][col + 1].previousNode = node;\r\n        return true;\r\n      }\r\n    }\r\n    if (row < grid.length - 1) {\r\n      if (DFSUtil(grid[row + 1][col], finishNode, grid, visitedNodesInOrder)) {\r\n        grid[row + 1][col].previousNode = node;\r\n        return true;\r\n      }\r\n    }\r\n    if (col > 0) {\r\n      if (DFSUtil(grid[row][col - 1], finishNode, grid, visitedNodesInOrder)) {\r\n        grid[row][col - 1].previousNode = node;\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function getNodesInPathOfDFS(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n"],"mappings":"AAAA,OAAO,SAASA,GAAGA,CAACC,IAAI,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAC/C,MAAMC,mBAAmB,GAAG,EAAE;EAC9BC,OAAO,CAACH,SAAS,EAAEC,UAAU,EAAEF,IAAI,EAAEG,mBAAmB,CAAC;EACzD,OAAOA,mBAAmB;AAC5B;AAACE,EAAA,GAJeN,GAAG;AAMnB,SAASK,OAAOA,CAACE,IAAI,EAAEJ,UAAU,EAAEF,IAAI,EAAEG,mBAAmB,EAAE;EAC5D,IAAI,CAACG,IAAI,CAACC,SAAS,IAAI,CAACD,IAAI,CAACE,MAAM,EAAE;IACnCF,IAAI,CAACC,SAAS,GAAG,IAAI;IACrBJ,mBAAmB,CAACM,IAAI,CAACH,IAAI,CAAC;IAC9BI,OAAO,CAACC,GAAG,CAACL,IAAI,CAAC;IACjB,IAAIA,IAAI,KAAKJ,UAAU,EAAE,OAAO,IAAI;IACpC,MAAM;MAAEU,GAAG;MAAEC;IAAI,CAAC,GAAGP,IAAI;IACzB,IAAIM,GAAG,GAAG,CAAC,EAAE;MACX,IAAIR,OAAO,CAACJ,IAAI,CAACY,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,EAAEX,UAAU,EAAEF,IAAI,EAAEG,mBAAmB,CAAC,EAAE;QACtEH,IAAI,CAACY,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,YAAY,GAAGR,IAAI;QACtC,OAAO,IAAI;MACb;IACF;IACA,IAAIO,GAAG,GAAGb,IAAI,CAAC,CAAC,CAAC,CAACe,MAAM,GAAG,CAAC,EAAE;MAC5B,IAAIX,OAAO,CAACJ,IAAI,CAACY,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,EAAEX,UAAU,EAAEF,IAAI,EAAEG,mBAAmB,CAAC,EAAE;QACtEH,IAAI,CAACY,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAACC,YAAY,GAAGR,IAAI;QACtC,OAAO,IAAI;MACb;IACF;IACA,IAAIM,GAAG,GAAGZ,IAAI,CAACe,MAAM,GAAG,CAAC,EAAE;MACzB,IAAIX,OAAO,CAACJ,IAAI,CAACY,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,EAAEX,UAAU,EAAEF,IAAI,EAAEG,mBAAmB,CAAC,EAAE;QACtEH,IAAI,CAACY,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,YAAY,GAAGR,IAAI;QACtC,OAAO,IAAI;MACb;IACF;IACA,IAAIO,GAAG,GAAG,CAAC,EAAE;MACX,IAAIT,OAAO,CAACJ,IAAI,CAACY,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,EAAEX,UAAU,EAAEF,IAAI,EAAEG,mBAAmB,CAAC,EAAE;QACtEH,IAAI,CAACY,GAAG,CAAC,CAACC,GAAG,GAAG,CAAC,CAAC,CAACC,YAAY,GAAGR,IAAI;QACtC,OAAO,IAAI;MACb;IACF;EACF;EACA,OAAO,KAAK;AACd;AAACU,GAAA,GAjCQZ,OAAO;AAmChB,OAAO,SAASa,mBAAmBA,CAACf,UAAU,EAAE;EAC9C,MAAMgB,wBAAwB,GAAG,EAAE;EACnC,IAAIC,WAAW,GAAGjB,UAAU;EAC5B,OAAOiB,WAAW,KAAK,IAAI,EAAE;IAC3BD,wBAAwB,CAACE,OAAO,CAACD,WAAW,CAAC;IAC7CA,WAAW,GAAGA,WAAW,CAACL,YAAY;EACxC;EACA,OAAOI,wBAAwB;AACjC;AAAC,IAAAb,EAAA,EAAAW,GAAA;AAAAK,YAAA,CAAAhB,EAAA;AAAAgB,YAAA,CAAAL,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}